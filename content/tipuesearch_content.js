var tipuesearch = {"pages": [{'title': 'About', 'text': '組員: \n (1)學號:40923115 帳號: jason60714 ip:\xa0 [2001:288:6004:17:2023:cdb:5:1]:23020 \n (2)學號:40923130 帳號:Martin3130  [2001:288:6004:17:2023:cdb:5:2]:23020 \n (3) 學號: 40923235  帳號: 40923235\xa0\xa0 [2001:288:6004:17:2023:cdb:5:3]:23020 \n (4) 學號: 41023202  帳號: ting0111  [2001:288:6004:17:2023:cdb:5:4]:23020/ \n (5) 學號: 41023212  帳號: youqui0411 [2001:288:6004:17:2023:cdb:5:5]:23020 \n (6) 學號: 41023229  帳號: CHI1020\xa0\xa0\xa0  [2001:288:6004:17:2023:cdb:5:6]:23020 \n (7) 學號: 41023242  帳號: 41023242\xa0   [2001:288:6004:17:2023:cdb:5:7]:23020 \n 組長: \n (8) 學號: 41023252  帳號: ZYC0923\xa0\xa0\xa0  [2001:288:6004:17:2023:cdb:5:8]:23020 \n 倉儲: \n \xa0 \xa0 \xa0\xa0   https://github.com/mdecd2023/2b3-pj3bg5 \n 網站： \n \xa0 \xa0 \xa0\xa0  https://mdecd2023.github.io/2b3-pj3bg5/content/index.html \n \n \xa0 \n', 'tags': '', 'url': 'About.html'}, {'title': '網站更新步驟', 'text': '1.個人的 fork 倉儲點選 Sync fork \n 2.打開資料夾 \n 3.點選 start_ipv6.bat \n 4.輸入 cd 資料夾名稱 並且 git pull \n 5.cms \n 6.貼上網址進行動態網頁編輯 \n 7.acp \n 8.點選個人 fork 倉儲 Open pull request \n 9.回到整組倉儲 merge pull request \n \xa0 \n', 'tags': '', 'url': '網站更新步驟.html'}, {'title': 'group', 'text': '\n 亂數 \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  亂數 開始  \n \n \n  亂數 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n \n', 'tags': '', 'url': 'group.html'}, {'title': '場地', 'text': '場地 \n \n 場地(有感應線.zip \n \n 第一版(8台wali) \n \n \n 第二版(4台bubbleRob、4台wali) \n 由於8台wali會造成延遲，所以將4台改為bubbleRob。 \n \n \n 場景(修改) \n \n \n \n \n PJ3場景 \n 最新完整版 \n 控制碼 \n', 'tags': '', 'url': '場地.html'}, {'title': '進球顯示背號', 'text': '\n 背號版 \n', 'tags': '', 'url': '進球顯示背號.html'}, {'title': '記分板', 'text': '第一代記分板onshape \n \n \n \n 第二代solidworks(未組裝) \n 第三代記分板onshape (組裝) \n \n \n', 'tags': '', 'url': '記分板.html'}, {'title': '機器人', 'text': '41023202 \n 41023202組合 \n \n 41023212 \n 41023212組合.zip \n \n 41023229 \n 41023229機械人 \n \n 41023242 \n 41023242機械人 \n \n 41023252 \n 41023252機械人 \n \n 40923130 \n 40923130機器人 \n \n 40923115 \n 40923115 機器人 \n \n 40923235 \n 40923235 機器人 \n \n \n 機器人影片 \n 瓦利機器人 \n \n', 'tags': '', 'url': '機器人.html'}, {'title': '協同設計', 'text': '球場 \n 影片 \n \n  接下來將 mp4 檔案從 downloads 目錄取出  \n \n \n', 'tags': '', 'url': '協同設計.html'}, {'title': '分配工作', 'text': '40923115:使用solidworks繪製機器人本體，按照規格所要求的畫，研究latex，轉乘ppt，改良自己的機器人。 \n 40923130:繪製自己的機器人，更改joint與輪子名稱，寫wali程式碼，改良BubbleRob，寫BubbleRob程式碼，尋找與修改記分板程式碼。 \n 40923235:繪製自己的機器人，研究latex。 \n 41023202:詢問許多同學步驟，首先先製作足球機器人。我是先用solidworks畫出機器人的本體，按照規格所要求的畫。之後再把檔案存成stl檔。接著畫出輪子(含輪框)、軸各為一份檔案。也是存成stl檔案。接著再畫出場地，按照尺寸設計以及需求，也是存成stl檔案。 \n 41023212:負責畫出自己的機器人，並嘗試帶入計分器的程式，與別組已完成的同學討論，新增機器人背數 \n 41023229:負責畫機器人和裝機器人的軸作動跟畫記分板，組裝記分板和製作分組報告。 \n 41023242:負責主持會議、錄製影片、交代任務，尋找可能會發生哪些問題並盡快提早解決，畫機器人、畫記分板、組裝軸 \n 41023252:負責畫出自己的機器人，將機器人裝上轉軸作動，解決cmd及網站倉儲問題，修改、測試記分板程式問題。 \n \n', 'tags': '', 'url': '分配工作.html'}, {'title': '會議記錄', 'text': '5/23開會目的:各自設計一個球員 \n \n \n 5/24開會目的:將設計好的球員加上輪子匯入CoppeliaSim嘗試 \n \n \n \n \n \n 5月31日:把各自的機器人做修改並上傳，我們把場地跟球框重畫了，之前是場地球框分開畫，現在我們畫在一起這樣在協同的過程中比較方便進行，最後有讓我們的機器人裝上軸並試著走走看 \n', 'tags': '', 'url': '會議記錄.html'}, {'title': 'Wali程式碼', 'text': "# pip install pyzmq cbor keyboard\nfrom zmqRemoteApi_IPv6 import RemoteAPIClient\n#from zmqRemoteApi import RemoteAPIClient\nimport keyboard\n\n#client = RemoteAPIClient('localhost', 23000)\nclient = RemoteAPIClient('2001:288:6004:17:2023:cdb:5:2', 23000)\n\nprint('Program started')\nsim = client.getObject('sim')\n\nsim.startSimulation()\nprint('Simulation started')\n\ndef setWaliRobVelocity(leftWheelVelocity, rightWheelVelocity):\n    leftMotor1 = sim.getObject('/leftMotor1')\n    leftMotor2 = sim.getObject('/leftMotor2')\n    rightMotor1 = sim.getObject('/rightMotor1')\n    rightMotor2 = sim.getObject('/rightMotor2')\n    sim.setJointTargetVelocity(leftMotor1, leftWheelVelocity)\n    sim.setJointTargetVelocity(leftMotor2, leftWheelVelocity)\n    sim.setJointTargetVelocity(rightMotor1, rightWheelVelocity)\n    sim.setJointTargetVelocity(rightMotor2, rightWheelVelocity)\n    \n'''\n# Example usage 1:\nsetBubbleRobVelocity(1.0, 1.0)\ntime.sleep(2)\nsetBubbleRobVelocity(0.0, 0.0)\n'''\n# use keyborad to move BubbleRob\n\nwhile True:\n    if keyboard.is_pressed('5'):\n        setWaliRobVelocity(3.0, 3.0)\n    elif keyboard.is_pressed('8'):\n        setWaliRobVelocity(-3.0, -3.0)\n    elif keyboard.is_pressed('6'):\n        setWaliRobVelocity(-3.0, 3.0)\n    elif keyboard.is_pressed('4'):\n        setWaliRobVelocity(3.0, -3.0)\n    elif keyboard.is_pressed('q'):\n        # stop simulation\n        sim.stopSimulation()\n    else:\n        setWaliRobVelocity(0.0, 0.0)\n\n\n \n \n 利用紅綠球控制之程式碼修改成Wali的程式碼 \n \n 第二版(降低操作延遲) \n # pip install pyzmq cbor keyboard\nfrom zmqRemoteApi_IPv6 import RemoteAPIClient\nimport keyboard\nimport time\n\n#client = RemoteAPIClient('localhost', 23000)\nclient = RemoteAPIClient('2001:288:6004:17:2023:cdb:5:2', 23000)\n\nprint('Program started')\nsim = client.getObject('sim')\n\nsim.startSimulation()\nprint('Simulation started')\n\ndef setWaliRobVelocity(leftWheelVelocity, rightWheelVelocity):\n    leftMotor1 = sim.getObject('/leftMotor1')\n    leftMotor2 = sim.getObject('/leftMotor2')\n    rightMotor1 = sim.getObject('/rightMotor1')\n    rightMotor2 = sim.getObject('/rightMotor2')\n    sim.setJointTargetVelocity(leftMotor1, leftWheelVelocity)\n    sim.setJointTargetVelocity(leftMotor2, leftWheelVelocity)\n    sim.setJointTargetVelocity(rightMotor1, rightWheelVelocity)\n    sim.setJointTargetVelocity(rightMotor2, rightWheelVelocity)\n\n# 使用非阻塞模式\nkeyboard.unhook_all()\n\n# 設定時間間隔\ninterval = 0.05\n\n# 初始化移動指令\nleftWheelVelocity = 0.0\nrightWheelVelocity = 0.0\n\nwhile True:\n    if keyboard.is_pressed('s'):\n        leftWheelVelocity = 10.0\n        rightWheelVelocity = 10.0\n    elif keyboard.is_pressed('w'):\n        leftWheelVelocity = -10.0\n        rightWheelVelocity = -10.0\n    elif keyboard.is_pressed('d'):\n        leftWheelVelocity = -2.0\n        rightWheelVelocity = 2.0\n    elif keyboard.is_pressed('a'):\n        leftWheelVelocity = 2.0\n        rightWheelVelocity = -2.0\n    elif keyboard.is_pressed('q'):\n        # stop simulation\n        sim.stopSimulation()\n        break\n    else:\n        leftWheelVelocity = 0.0\n        rightWheelVelocity = 0.0\n\n    # 發送移動指令\n    setWaliRobVelocity(leftWheelVelocity, rightWheelVelocity)\n\n    # \n \n", 'tags': '', 'url': 'Wali程式碼.html'}, {'title': '4輪BubbleRob程式碼', 'text': "\n 因為發現原有Wali機器人結構太複雜，放8隻機器人會導致操控上很延遲，所以將4隻改成PJ1和PJ2的BubbleRob改良成4個輪子，以下為程式碼 \n # pip install pyzmq cbor keyboard\nfrom zmqRemoteApi_IPv6 import RemoteAPIClient\n#from zmqRemoteApi import RemoteAPIClient\nimport keyboard\nimport time\n\n#client = RemoteAPIClient('localhost', 23000)\nclient = RemoteAPIClient('2001:288:6004:17:2023:cdb:5:2', 23000)\n\nprint('Program started')\nsim = client.getObject('sim')\nsim.startSimulation()\nprint('Simulation started')\n\ndef setBubbleRobVelocity(leftWheelVelocity, rightWheelVelocity):\n    leftMotor9 = sim.getObject('/leftMotor9')\n    rightMotor9 = sim.getObject('/rightMotor9')\n    leftMotor10 = sim.getObject('/leftMotor10')\n    rightMotor10 = sim.getObject('/rightMotor10')\n    sim.setJointTargetVelocity(leftMotor9, leftWheelVelocity)\n    sim.setJointTargetVelocity(rightMotor9, rightWheelVelocity)\n    sim.setJointTargetVelocity(leftMotor10, leftWheelVelocity)\n    sim.setJointTargetVelocity(rightMotor10, rightWheelVelocity)\n    \n# 使用非阻塞模式\nkeyboard.unhook_all()\n\n# 設定時間間隔\ninterval = 0.05\n\n# 初始化移動指令\nleftWheelVelocity = 0.0\nrightWheelVelocity = 0.0\n\nwhile True:\n    if keyboard.is_pressed('up'):\n        leftWheelVelocity = 10.0\n        rightWheelVelocity = 10.0\n    elif keyboard.is_pressed('down'):\n        leftWheelVelocity = -10.0\n        rightWheelVelocity = -10.0\n    elif keyboard.is_pressed('right'):\n        leftWheelVelocity = 10.0\n        rightWheelVelocity = -10.0\n    elif keyboard.is_pressed('left'):\n        leftWheelVelocity = -10.0\n        rightWheelVelocity = 10.0\n    elif keyboard.is_pressed('q'):\n        # stop simulation\n        sim.stopSimulation()\n        break\n    else:\n        leftWheelVelocity = 0.0\n        rightWheelVelocity = 0.0\n\n    # 發送移動指令\n    setBubbleRobVelocity(leftWheelVelocity, rightWheelVelocity)\n\n \n \n \n", 'tags': '', 'url': '4輪BubbleRob程式碼.html'}, {'title': '記分板程式碼', 'text': "function sysCall_init()\n    score = 0\n    wheelJoint = sim.getObjectHandle('/joint1r')\n    robot = {\n        sim.getObjectHandle('/wali1'),\n        sim.getObjectHandle('/wali2'),\n        sim.getObjectHandle('/wali3'),\n        sim.getObjectHandle('/wali4'),\n        sim.getObjectHandle('/bubbleRob5'),\n        sim.getObjectHandle('/bubbleRob6'),\n        sim.getObjectHandle('/bubbleRob7'),\n        sim.getObjectHandle('/bubbleRob8')\n    }\n\n    #給定機器人得分後復歸的位置\n    initialPos = {\n        {1.175, -1.12, 0.21},\n        {1.175, -0.62, 0.21},\n        {1.175, 0, 0.21},\n        {1.175, 0.5, 0.21},\n        {-1.050, 0.57479, 0.21},\n        {-1.050, 0.1002, 0.21},\n        {-1.050, -0.44968, 0.21},\n        {-1.050, -0.97493, 0.21}\n    }\n  #給定機器人得分後的轉向  \n    initialOri = {\n        {0, 0, 0},\n        {0, 0, 0},\n        {0, 0, 0},\n        {0, 0, 0},\n        {0, 0, 0},\n        {0, 0, 0},\n        {0, 0, 0},\n        {0, 0, 0}\n    }\n    displayHandles = {\n        sim.getObjectHandle('/display1'),\n        sim.getObjectHandle('/display2'),\n        sim.getObjectHandle('/display3'),\n        sim.getObjectHandle('/display4'),\n        sim.getObjectHandle('/display5'),\n        sim.getObjectHandle('/display6'),\n        sim.getObjectHandle('/display7')\n    }\n    displayParameters = {\n        {0, 0, 1, 0, 0, 1, 0},\n        {1, 0, 1, 1, 1, 0, 1},\n        {1, 0, 1, 1, 0, 1, 1},\n        {0, 1, 1, 1, 0, 1, 0},\n        {1, 1, 0, 1, 0, 1, 1},\n        {1, 1, 0, 1, 1, 1, 1},\n        {1, 0, 1, 0, 0, 1, 0},\n        {1, 1, 1, 1, 1, 1, 1}\n    }\n    goalEffectEnabled = false\n    lastGoalPlayer = nil\n    flashingState = false\n    flashingTimer = 0\n    goalHandle = sim.getObjectHandle('/goal')\n    flashingDuration = 0.5\n    flashingTimer = 0 \n    isFlashing = false\nend\n\nsensor = sim.getObject('./sensor')\ninitialPosBall = sim.getObjectPosition(sensor, -1)\nball = sim.getObject('/ball')\n\nfunction sysCall_actuation()\n    result = sim.readProximitySensor(sensor)\n    if (result > 0) then\n        score = score + 1\n        sim.setObjectPosition(ball, -1, {-0.15,-0.25,0.15})\n        \n        -- Rotate the wheel joint by 36 degrees\n        local currentAngle = sim.getJointPosition( wheelJoint)\n        local targetAngle = currentAngle + math.rad(-36)\n        sim.setJointTargetPosition( wheelJoint, targetAngle)\n        #對機器人5~8 針對場景坐標系(-1) 給定上面設定位置 \n        for i = 5, 8 do\n            sim.setObjectPosition(robot[i], -1, initialPos[i])\n            sim.setObjectOrientation(robot[i], -1, initialOri[i])\n        end\n        #對機器人1~4 針對機器人坐標系( robot[i]) 給定上面設定位置\n         for i = 1, 4 do\n            sim.setObjectOrientation(robot[i], robot[i], initialOri[i])\n        end\n        \n        goalEffectEnabled = true\n        lastGoalPlayer = result\n        flashingState = false\n        flashingTimer = 0\n    end\n    \n    if goalEffectEnabled then\n        if not isFlashing then\n            flashingTimer = flashingTimer + sim.getSimulationTimeStep()\n            if flashingTimer >= flashingDuration then\n                isFlashing = true\n                sim.setShapeColor(goalHandle, nil, sim.colorcomponent_ambient_diffuse, {1, 0.9, 0})\n            end\n        elseif isFlashing then\n            flashingTimer = flashingTimer + sim.getSimulationTimeStep()\n            if flashingTimer >= flashingDuration + 3 then\n                goalEffectEnabled = false\n                isFlashing = false\n                sim.setShapeColor(goalHandle, nil, sim.colorcomponent_ambient_diffuse, {0, 0, 0})\n            end\n        end\n    end\nend\n\nfunction sysCall_cleanup()\n    sim.setShapeColor(goalHandle, nil, sim.colorcomponent_ambient_diffuse,{0, 0, 0})\nend \n \n", 'tags': '', 'url': '記分板程式碼.html'}, {'title': '連線教學', 'text': '\n 進入防火牆進階設定，並且輸入規則。 \n \n 點選右側的新增規則。 \n \n \n \n 點選連接埠。 \n \n 選擇特定連接埠，打23000-23050。 \n \n 直接點選下一步。 \n \n 直接點選下一步。 \n \n 輸入名稱就完成了!! \n 辦法二 \n 在白框輸入 \n echo off netsh advirewall firewall add rule name="allow_23000-23050" dir=in action=allow protocol=TCP localport=23000-23050 \n 然後再language上按batch存檔完(名稱後加.bat)，在按使用者開啟 \n allow 23000-23050 \n', 'tags': '', 'url': '連線教學.html'}, {'title': '對戰影片', 'text': '因為組員1 場景無法正常開啟，所以改用組員2的IP來模擬 \n \n \n', 'tags': '', 'url': '對戰影片.html'}, {'title': '分組報告', 'text': 'pj3bg5分組報告 \n', 'tags': '', 'url': '分組報告.html'}]};